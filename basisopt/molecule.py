# molecule
import numpy as np
from .exceptions import InvalidDiatomic
import logging

class Molecule:
    """A very loose definition of a molecule, in that it represents
       an object with which calculations can be done. 
    
       Attributes:
            name (str): identifier
            charge (int): overall net charge
            multiplicity (int): spin multiplicity, i.e. 2S+1
            method (str): name of calculation method, e.g. 'hf' or 'ccsd(t)'
            basis (dict): internal basis dictionary, which has (k, v) pairs
            of the form (element_symbol : array of Shell objects)
            
       Private attributes:
            _atom_names (list): atom symbols in order, e.g. ['H', 'H', 'O']
            _coords (list): x,y,z coords in Angstrom, as numpy arrays, same
            order as _atom_names
            _results (dict): dictionary of results calculated for this molecule.
            NOTE: these results are NOT archived, unlike for a Result object
            _references (dict): dictionary of reference values for results
    """
    def __init__(self, name="Untitled", charge=0, mult=1):
        self.name = name
        self.charge = charge
        self.multiplicity = mult
        self.method = ""
        self.basis = {}
        self._atom_names = []
        self._coords = []
        self._results = {}
        self._references = {}
        
    def add_atom(self, element='H', coord=[0.0, 0.0, 0.0]): 
        """Adds an atom to the molecule
        
           Arguments:
                element (str): element name
                coord (list): [x,y,z] coords in Ansgtrom
        """
        self._coords.append(np.array(coord))
        self._atom_names.append(element)
    
    def add_result(self, name, value):
        """Store a result (no archiving)
        
           Arguments:
                name (str): identifier for result
                value (any): value of result
        """
        self._results[name] = value
        
    def get_result(self, name):
        """Returns:
                Value of result with given name if it exists,
                otherwise 0
        """
        try:
            return self._results[name]
        except KeyError:
            return 0.0
            
    def add_reference(self, name, value):
        """Same as add_result but for reference values"""
        self._references[name] = value
        
    def get_reference(self, name):
        """Same as get_result but for reference values"""
        try:
            return self._references[name]
        except KeyError:
            return 0.0        
    
    def get_delta(self, name):
        """Returns:
                Difference between a result and its reference value
        """
        return (self.get_result(name) - self.get_reference(name))
    
    def from_xyz(self, filename): 
        """Creates a Molecule from an xyz file
           
           Arguments:
                filename (str): path to xyz file
        """
        try:
            # Read in xyz file
            f = open(filename, 'r')
            lines = f.readlines()
            
            # Reset molecule
            self._atom_names = []
            self._coords = []
            
            # parse
            # first line should be natoms
            nat = int(lines[0])
            # second line is title
            for line in lines[2:2+nat]:
                words = line.split()
                element = words[0]
                coords = np.array([float(w) for w in words[1:4]])
                self.add_atom(element=element, coord=coords)
        except IOError as e:
            logging.error(f"I/O error({e.errno}): {e.strerror}")
        except:
            logging.error(f"Incorrect formatting in {filename}")
        
    def to_xyz(self):
        """Converts Molecule to xyz file format
        
           Returns:
                a string of the Molecule in xyz file format
        """
        output = f"{self.natoms()}\n{self.name}, generated by BasisOpt\n"
        for i in range(self.natoms()):
            output += self.get_line(i) + "\n"
        return output
    
    def get_line(self, i):
        """Gets a line of the xyz file representation of the Molecule
        
           Arguments:
                i (int): the index of the atom line wanted
        
           Returns:
                a string of form {element} {coords}
        """
        ix = max(i, 0)
        ix = min(ix, len(self._atom_names)-1)
        n, c = self._atom_names[ix], self._coords[ix]
        return f"{n}\t{c[0]}\t{c[1]}\t{c[2]}"
        
    def natoms(self):
        """Returns number of atoms in Molecule"""
        return len(self._atom_names)
        
    def unique_atoms(self):
        """Returns a list of all unique atom types in Molecule"""
        return list(set(self._atom_names))
        
    def distance(self, atom1, atom2):
        """Computes the Euclidean distance between two atoms.
           No bounds checking.
        
           Arguments:
                atom1, atom2 (int): indices of atoms
        
           Returns:
                the Euclidean separation in Angstrom
        """
        c1 = self._coords[atom1]
        c2 = self._coords[atom2]
        return np.linalg.norm(c1 - c2)
        
def build_diatomic(mol_str, charge=0, mult=1):
    """Builds a diatomic molecule from a string
    
       Arguments:
            mol_str (str): string of diatomic and separation in Angstrom
            e.g. "NO,1.3", "H2,0.9", "LiH,1.1" etc
            charge (int): net molecular charge
            mult (int): spin multiplicity
    
       Returns:
            Molecule object of diatomic
    
       Raises:
            IndexError when rval not given in mol_str
            InvalidDiatomic when mol_str can't be parsed
            error checking isn't exhaustive
    """
    molecule = Molecule(name=mol_str+"_Diatomic", charge=charge, mult=mult)
    # parse the mol string, form "Atom1Atom2,Separation(ang)"
    parts = mol_str.split(',')
    chars = list(parts[0])
    rval = float(parts[1])
    nchars = len(chars)
    if nchars == 2:
        # either something like NO or N2
        if chars[1] == '2':
            atom1 = atom2 = chars[0]
        elif chars[1].islower() or chars[1].isdigit(): 
            # monoatom, eg He, or multiatom eg C6
            return InvalidDiatomic
        else:
            atom1 = chars[0]
            atom2 = chars[1]
    elif nchars==3:
        if chars[2] == '2':
            atom1 = atom2 = "".join(chars[:2])
        elif chars[1].isupper():
            atom1 = chars[0]
            atom2 = "".join(chars[1:])
        elif chars[1].isdigit():
            # eg H2O
            raise InvalidDiatomic
        else:
            atom1 = "".join(chars[:2])
            atom2 = chars[2]
    elif nchars==4:
        atom1 = "".join(chars[:2])
        atom2 = "".join(chars[2:4])
    else:
        raise InvalidDiatomic
    
    molecule.add_atom(element=atom1, coord=[0.0, 0.0, -0.5*rval])
    molecule.add_atom(element=atom2, coord=[0.0, 0.0,  0.5*rval])
    return molecule
        